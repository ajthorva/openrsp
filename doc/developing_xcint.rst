

Contributing to the XCint development
=====================================


Getting the latest development code and committing changes
----------------------------------------------------------

Get the latest development code from https://repo.ctcc.no/projects/xcint.
Write to Radovan Bast <radovan.bast@uit.no> to get access to the repository.

DIRAC developers please commit changes to the DIRAC repository.

Developers outside the DIRAC group please pull/push changes from/to
https://repo.ctcc.no/projects/xcint.


Interfacing your code with XCint
================================


Bindings
--------

So far only Fortran 90.


XCFun
-----

XCint obtains XC functional derivatives using the XCFun library of Ulf Ekstrom
and coworkers.


Which sources to compile
------------------------

You can either build libxcint.a separately and link your application against it,
or you compile the XCint sources directly by the build mechanism of your code.


Setting the XC functional (with XCFun)
--------------------------------------

The following minimal code will set the LDA XC functional::

  use xc_derv
  use interface_functional_read

  character(80) :: line
  real(8)       :: hfx_out, mu_out, beta_out

  line = 'lda       '// &
         '          '// &
         '          '// &
         '          '// &
         '          '// &
         '          '// &
         '          '// &
         '          '
  call parse_functional(line, xc_fun, hfx_out, mu_out, beta_out, .true.)
  fun_is_automatic = .true.

The subroutine parse_functional sets xc_fun and returns hfx_out, mu_out,
beta_out that you can use in your parent code.


Numerical grid
--------------

XCint does not generate the numerical grid but assumes that the numerical grid
has been generated by whatever means and that it is on a free-format formatted
file called "numerical_grid".

File "numerical_grid" contains one or several batches of points. Each point
fills one line with x-, y-, z-coordinates and the weight. The file closes with
a negative integer.  Example: test/lda_energy/numerical_grid (3 batches with
650, 400, 400 points, respectively).


Basis set and molecular orbital information
-------------------------------------------

XCint needs a number of basis set (AO) and molecular orbital (MO) information
(both required).  For the SAOP asymptotic correction XCint additionaly needs MO
coefficients (optional).  This information is read from free-format formatted
files called "interface_ao", "interface_mo", and "interface_mo_coef".  Your
code needs to generate these files.  Have a look in test/lda_energy for
examples.

interface_ao:

- all coordinates in bohr
- is_spherical "F" means cartesian GTO, "T" means spherical GTO
- use_only_large "T" is what you want outside of the DIRAC code, and all primitives "L"
- coefficients (coef) contain normalization
- algebra: use 1 (means real; 1, 2, 4 is for DIRAC)

interface_mo:
typically you only need to set

- nr_electrons_inactive (number of closed-shell electrons)
- nr_mo_gerade_positive_inactive (nr of occupied orbitals)
- nr_mo_gerade_positive_secondary (nr of virtual orbitals)
- mo_eigenvalues (for asymptotic correction)

interface_mo_coef:

- first line contains number of matrix elements (nr_ao*nr_mo*nr_quaternion_units)
  nr_quaternion_units is typically 1


Integration, finally
--------------------

This is a minimal example to integrate the XC potential matrix::

  use xcint_main

  call integrate_xc(                         &
                     xc_mat_dim      = nr_ao, &
                     xc_nz           = 1,     &
                     xc_dmat_0       = dmat,  &
                     xc_nr_dmat      = 0,     &
                     xc_nr_fmat      = 1,     &
                     xc_fmat         = fmat,  &
                     xc_do_potential = .true. &
                    )

xc_dmat_0 is the unperturbed AO density matrix with the dimensions dmat(nr_ao,
nr_ao) allocated and calculated by your code.  Also xc_fmat is allocated by
your code with the dimensions fmat(nr_ao, nr_ao, 1, 1).  Note that XCint will
integrate on top of fmat and therefore not zero fmat.
